<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Basement Noise • Producer Linker</title>

  <!-- p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/addons/p5.sound.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&family=Courier+Prime&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#000; --ink:#f3f3f3; --muted:#bcbcbc;
      --frame:#d9d9d9;          /* light line for the canvas frame */
      --panel:#0f0f10;          /* very subtle transparent card */
      --maxw:1100px;
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:#000;color:var(--ink);font-family:"Courier Prime",monospace}
    a{color:inherit}

    /* === Global moving background (same as home) === */
    #bgCanvas{ position:fixed; inset:0; z-index:0; }
    .scanlines{ position:fixed; inset:0; pointer-events:none; z-index:0;
      background: repeating-linear-gradient(to bottom,
        rgba(255,255,255,.02) 0px, rgba(255,255,255,.02) 1px,
        transparent 2px, transparent 3px); }
    .vignette{ position:fixed; inset:0; z-index:0; pointer-events:none;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0) 40%, rgba(0,0,0,.55) 100%); }

    /* === Header (matches home) === */
    .site-header{
      position:sticky; top:0; z-index:20;
      background:rgba(0,0,0,.85);
      border-bottom:1px solid #191919;
      backdrop-filter: blur(6px);
    }
    .bar{
      max-width:var(--maxw); margin:0 auto; padding:10px 16px;
      display:flex; align-items:center; justify-content:space-between; gap:16px;
    }
    .brand{display:flex; align-items:center; gap:12px; text-decoration:none}
    .brand img{height:36px; width:auto; filter: drop-shadow(0 0 10px rgba(255,255,255,.12))}
    .brand .name{
      font-family:Orbitron, sans-serif; letter-spacing:2px; font-size:1rem;
      animation:glitch 2.2s linear infinite;
    }
    @keyframes glitch{
      0%,100%{ text-shadow:0 0 12px #fff, 2px -2px 0 #f00, -2px 2px 0 #0ff }
      50%    { text-shadow:0 0 12px #fff, -2px 2px 0 #f00, 2px -2px 0 #0ff }
    }
    nav a{display:inline-block; margin-left:10px; padding:6px 10px; border:1px solid #2e2e2e; border-radius:8px; text-decoration:none}
    nav a:hover{border-color:#fff; background:#fff; color:#000}

    /* === Title === */
    .hero{ max-width:var(--maxw); margin:28px auto 8px; padding:0 16px; text-align:center; position:relative; z-index:5; }
    .title{ font-family:Orbitron, sans-serif; letter-spacing:3px; font-size:2rem; margin:4px 0 6px; text-shadow:0 0 20px rgba(255,255,255,.08); }
    .subtitle{ color:var(--muted); margin:0; }

    /* === Tool wrapper (subtle—no heavy shadows) === */
    .wrap{ max-width:var(--maxw); margin:18px auto 40px; padding:0 16px; position:relative; z-index:5; }
    .panel{
      background: rgba(15,15,16,.32);     /* translucent, lets bg show through */
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      backdrop-filter: blur(2px);
      padding: 18px;
      /* removed drop shadows for cleaner look */
    }

    /* Controls */
    .controls{
      display:flex; flex-wrap:wrap; gap:10px; justify-content:center;
      margin:4px 0 14px;
    }
    .ui, .controls input[type="text"]{
      background:#111; color:#fff; border:1px solid #fff; border-radius:8px;
      padding:10px 14px; font:16px/1 "Courier Prime",monospace; cursor:pointer;
      transition:.15s all ease; box-shadow:0 0 8px rgba(255,255,255,.12) inset;
    }
    .ui:hover, .controls input[type="text"]:focus{ background:#fff; color:#000; outline:none }
    .controls input[type="file"]{ display:none }
    label.ui{ cursor:pointer }

    /* Canvas frame — simple line, no glow */
    #canvas-frame{
      border:1px solid rgba(255,255,255,.35);
      border-radius:10px;
      overflow:hidden;       /* clips the canvas corners */
      background: transparent;
    }
    /* the container that holds the p5 canvas element */
    #canvas-container{ width:100%; height:100%; }

    .note{ color:#9f9f9f; font-size:.9rem; text-align:center; margin-top:10px }
    footer{ color:#8a8a8a; font-size:.88rem; padding:26px 16px 40px; text-align:center; position:relative; z-index:5; }
  </style>
</head>
<body>

  <!-- Moving BG -->
  <canvas id="bgCanvas"></canvas>
  <div class="scanlines"></div>
  <div class="vignette"></div>

  <!-- Header -->
  <div class="site-header">
    <div class="bar">
      <a class="brand" href="/basement-noise/">
        <img src="/basement-noise/basement_noise_logo_design.png" alt="Basement Noise">
        <span class="name">Basement Noise</span>
      </a>
      <nav>
        <a href="/basement-noise/">Home</a>
        <a href="/basement-noise/tools/wheel-decide/">Wheel Decide</a>
        <a href="/basement-noise/tools/producer-linker/">Producer Linker</a>
      </nav>
    </div>
  </div>

  <!-- Title -->
  <div class="hero">
    <h1 class="title">Producer Type Beat Linker</h1>
    <p class="subtitle">Upload producers, add prompts, and assign them with a retro zap.</p>
  </div>

  <!-- Tool -->
  <main class="wrap">
    <section class="panel">
      <div class="controls">
        <label for="upload-face" class="ui" title="Upload a producer image">Upload Producer</label>
        <input type="file" id="upload-face" accept="image/*">
        <input type="text" id="topic-input" placeholder="Add prompt/genre…">
        <button id="add-topic" class="ui">Add Prompt</button>
        <button id="link-button" class="ui">Assign Random</button>
        <button id="reset-button" class="ui">Clear Links</button>
        <button id="remove-button" class="ui">Remove Last Free</button>
      </div>

      <!-- clean frame, no glow -->
      <div id="canvas-frame">
        <div id="canvas-container"></div>
      </div>

      <p class="note">Tip: click a linked prompt to unlink it • drag faces or prompts to rearrange • first click enables sound.</p>
    </section>
  </main>

  <footer>© Basement Noise</footer>

  <!-- ========== p5 sketch ========== -->
  <script>
    /* ===== Moving background (identical to home) ===== */
    (function(){
      const c = document.getElementById('bgCanvas');
      const ctx = c.getContext('2d', { alpha: false });
      let w,h,t=0;
      function resize(){ w = c.width = innerWidth; h = c.height = innerHeight; }
      addEventListener('resize', resize); resize();

      function drawGrain(){
        const img = ctx.getImageData(0,0,w,h), d = img.data;
        for(let i=0;i<d.length;i+=4){ const n = 8 + (Math.random()*12)|0; d[i]=d[i+1]=d[i+2]=n; }
        ctx.putImageData(img,0,0);
      }
      function drawStairs(){
        ctx.save(); ctx.globalAlpha=.05; ctx.strokeStyle='#fff'; ctx.lineWidth=2;
        const steps=6, bx=w*0.12+Math.sin(t*.0008)*w*.02, by=h*0.25+Math.cos(t*.0006)*h*.02;
        for(let s=0;s<steps;s++) ctx.strokeRect(bx+s*26, by+s*18, 120, 34);
        const rx=w*0.68+Math.cos(t*.0007)*w*.02, ry=h*0.62+Math.sin(t*.0005)*h*.02;
        for(let s=0;s<steps;s++) ctx.strokeRect(rx-s*24, ry-s*16, 140, 36);
        ctx.restore();
      }
      function tick(now){
        t = now; ctx.fillStyle='#000'; ctx.fillRect(0,0,w,h);
        drawGrain(); drawStairs(); requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    })();


    /* ===== Producer Linker (p5) ===== */

    // Globals
    let faces = [], topics = [], particles = [], canvas;
    let noise, noiseEnv, osc, oscEnv, oscFail, oscFailEnv;
    let soundInitialized = false;
    let notes = [110,130.81,146.83,164.81,196,220];
    let draggedObject = null, shakeAmount = 0, zaps = [];
    const FACE_SIZE = 80, TOPIC_HEIGHT = 30, PARTICLE_COUNT = 30;

    // Sizing: exact fit of the frame (no black strip)
    function getCanvasSize(){
      const frame = document.getElementById('canvas-frame');
      const w = Math.min(frame.clientWidth, 1000); // keep sane max width
      const h = Math.round(w * 0.60);
      return { w, h };
    }

    function setup(){
      const {w,h} = getCanvasSize();
      canvas = createCanvas(w, h);
      canvas.parent('canvas-container');
      canvas.elt.style.display = 'block';   // removes inline gap
      pixelDensity(1); frameRate(60);
      textAlign(CENTER, CENTER); textFont('Courier New'); rectMode(CENTER);

      document.getElementById('upload-face').addEventListener('change',(e)=>{
        if (e.target.files && e.target.files[0]){
          const reader = new FileReader();
          reader.onload = (ev)=> loadImage(ev.target.result, (img)=> faces.push(new Face(img)));
          reader.readAsDataURL(e.target.files[0]);
        }
      });

      select('#add-topic').mousePressed(addTopic);
      select('#topic-input').elt.addEventListener('keyup', (e)=>{ if(e.key==='Enter') addTopic(); });
      select('#link-button').mousePressed(linkRandom);
      select('#reset-button').mousePressed(resetLinks);
      select('#remove-button').mousePressed(removeLast);
    }

    function windowResized(){
      const {w,h} = getCanvasSize();
      resizeCanvas(w,h);
    }

    function draw(){
      // FULL CLEAR to prevent ghost trails
      background(12);

      // optional soft static overlay
      drawStatic();

      // Shake
      push();
      if (shakeAmount>0){ translate(random(-shakeAmount,shakeAmount), random(-shakeAmount,shakeAmount)); shakeAmount--; }

      // Particles + zaps
      for(let i=particles.length-1;i>=0;i--){ particles[i].update(); particles[i].display(); if(particles[i].isDead()) particles.splice(i,1); }
      for(let i=zaps.length-1;i>=0;i--){ drawZap(zaps[i]); zaps[i].life--; if(zaps[i].life<=0) zaps.splice(i,1); }

      // Hover state
      let hovering = false;
      for (let i=topics.length-1;i>=0;i--) if (topics[i].checkHover()) hovering = true;
      for (let i=faces.length-1;i>=0;i--) if (!hovering && faces[i].checkHover()) hovering = true;

      if (draggedObject) canvas.style('cursor','grabbing');
      else if (hovering) canvas.style('cursor','grab');
      else canvas.style('cursor','default');

      for (let f of faces){ f.update(); f.display(); }
      for (let t of topics){ t.update(); t.display(); }

      pop();
      drawSpeckles();
    }

    // UI actions
    function addTopic(){
      const v = select('#topic-input').value(); if(!v.trim()) return;
      topics.push(new Topic(v)); select('#topic-input').value('');
    }
    function createParticleBurst(x,y){ for(let i=0;i<PARTICLE_COUNT*1.5;i++) particles.push(new Particle(x,y)); }
    function linkRandom(){
      let unFaces = faces.filter(f=>!f.linkedTopic);
      let unTopics = topics.filter(t=>!t.isLinked);
      if (unFaces.length && unTopics.length){
        let f = unFaces[floor(random(unFaces.length))];
        let t = unTopics[floor(random(unTopics.length))];
        f.linkedTopic = t; t.isLinked = true; t.linkedFace = f;
        f.triggerGlitch(); createParticleBurst(f.pos.x, f.pos.y);
        zaps.push({from:f.pos.copy(), to:t.pos.copy(), life:20});
        if (soundInitialized){ osc.freq(random(notes)); noiseEnv.play(noise); oscEnv.play(osc); }
      } else triggerError();
    }
    function resetLinks(){ for(let f of faces) f.linkedTopic=null; for(let t of topics){ t.isLinked=false; t.linkedFace=null; } }
    function removeLast(){
      for(let i=faces.length-1;i>=0;i--) if(!faces[i].linkedTopic){ faces.splice(i,1); break; }
      for(let i=topics.length-1;i>=0;i--) if(!topics[i].isLinked){ topics.splice(i,1); break; }
    }
    function triggerError(){ shakeAmount = 10; if (soundInitialized) oscFailEnv.play(oscFail); }

    // Init sound on first click
    function initSound(){
      if (typeof userStartAudio!=='function'){ console.error('p5.sound not loaded'); return false; }
      userStartAudio();
      try{
        noise = new p5.Noise('white'); noise.amp(0); noise.start();
        noiseEnv = new p5.Env(); noiseEnv.setADSR(.01,.1,0,.1);
        osc = new p5.Oscillator('sine'); osc.amp(0); osc.start();
        oscEnv = new p5.Env(); oscEnv.setADSR(.01,.2,.1,.3); oscEnv.setRange(.5,0);
        oscFail = new p5.Oscillator('sawtooth'); oscFail.freq(60); oscFail.amp(0); oscFail.start();
        oscFailEnv = new p5.Env(); oscFailEnv.setADSR(.01,.05,0,.05); oscFailEnv.setRange(.3,0);
        soundInitialized = true; return true;
      }catch(e){ console.error('sound init fail',e); return false; }
    }
    function mousePressed(){
      if (!soundInitialized){ initSound(); return; }
      for (let i=topics.length-1;i>=0;i--){
        let t = topics[i];
        if (t.isLinked && t.isHovered){ if (t.linkedFace) t.linkedFace.linkedTopic=null; t.isLinked=false; t.linkedFace=null; return; }
      }
      if (!draggedObject){ for(let i=topics.length-1;i>=0;i--) if (topics[i].isHovered){ draggedObject=topics[i]; break; } }
      if (!draggedObject){ for(let i=faces.length-1;i>=0;i--) if (faces[i].isHovered){ draggedObject=faces[i]; break; } }
      if (draggedObject){ draggedObject.isDragging=true; draggedObject.dragOffset.set(draggedObject.pos.x-mouseX, draggedObject.pos.y-mouseY); canvas.style('cursor','grabbing'); }
    }
    function mouseDragged(){ if (draggedObject) draggedObject.pos.set(mouseX+draggedObject.dragOffset.x, mouseY+draggedObject.dragOffset.y); }
    function mouseReleased(){ if (draggedObject){ draggedObject.isDragging=false; draggedObject=null; canvas.style('cursor','grab'); } }

    // FX
    function drawSpeckles(){ stroke(255,15); strokeWeight(1); for(let i=0;i<300;i++) point(random(width), random(height)); }
    function drawStatic(){ noStroke(); for(let i=0;i<8;i++){ fill(255, 8); rect(random(width), random(height), random(width/2), random(height/10)); } }
    function drawZap(z){
      push(); let a = map(z.life,0,20,0,255);
      stroke(255,255,0,a); strokeWeight(3+z.life*.2);
      let m = p5.Vector.lerp(z.from,z.to,.5); m.add(p5.Vector.random2D().mult(z.life*1.5));
      noFill(); beginShape(); vertex(z.from.x,z.from.y); vertex(m.x,m.y); vertex(z.to.x,z.to.y); endShape();
      stroke(255,a); strokeWeight(1+z.life*.1);
      beginShape(); vertex(z.from.x,z.from.y); vertex(m.x,m.y); vertex(z.to.x,z.to.y); endShape(); pop();
    }

    // Base classes
    class BaseItem{
      constructor(x,y,r){ this.pos=createVector(x,y); this.radius=r; this.isDragging=false; this.dragOffset=createVector(0,0); this.isHovered=false; }
      checkHover(){ if(this.isDragging){ this.isHovered=false; return false; } const d=dist(mouseX,mouseY,this.pos.x,this.pos.y); this.isHovered = d<this.radius; return this.isHovered; }
      update(){}
    }
    class Face extends BaseItem{
      constructor(img){ super(random(FACE_SIZE/2, width-FACE_SIZE/2), random(FACE_SIZE/2, height/2), FACE_SIZE/2);
        this.img=img; this.img.filter(GRAY); this.linkedTopic=null; this.glitchAmount=0; }
      triggerGlitch(){ this.glitchAmount=1; }
      update(){ this.glitchAmount = max(0, this.glitchAmount - .05); }
      display(){
        push(); translate(this.pos.x,this.pos.y); imageMode(CENTER);
        if(this.isHovered && !this.isDragging) scale(1.05);
        if(this.glitchAmount>0){
          let gx=random(-5,5)*this.glitchAmount, gy=random(-5,5)*this.glitchAmount;
          drawingContext.globalCompositeOperation='lighter';
          tint(255,0,0,150*this.glitchAmount); image(this.img,gx,gy,FACE_SIZE,FACE_SIZE);
          tint(0,255,0,150*this.glitchAmount); image(this.img,-gx,-gy,FACE_SIZE,FACE_SIZE);
          tint(0,0,255,150*this.glitchAmount); image(this.img,gx/2,gy/2,FACE_SIZE,FACE_SIZE);
          drawingContext.globalCompositeOperation='source-over'; noTint();
        }
        if(this.glitchAmount>0) tint(255,255*(1-this.glitchAmount*.5));
        image(this.img,0,0,FACE_SIZE,FACE_SIZE); noTint();
        noFill(); stroke(this.isHovered? 'rgb(0,255,0)':'#fff'); strokeWeight(this.isHovered?3:2);
        rect(0,0,FACE_SIZE+2,FACE_SIZE+2,8); pop();
      }
    }
    class Topic extends BaseItem{
      constructor(text){
        let w = textWidth(text)+30;
        super(random(w/2, width-w/2), random(height/2, height-TOPIC_HEIGHT/2), max(w/2, TOPIC_HEIGHT/2));
        this.text=text; this.width=w; this.height=TOPIC_HEIGHT; this.isLinked=false; this.linkedFace=null; this.pulse=random(1); this.pulseDir=1;
      }
      update(){
        if(this.isLinked && this.linkedFace){
          let ty = this.linkedFace.pos.y - this.linkedFace.radius - (this.height/2) - 10;
          if(ty < this.height/2) ty = this.height/2;
          this.pos.x = this.linkedFace.pos.x; this.pos.y = ty;
          this.pulse += this.pulseDir*.05; if(this.pulse>1 || this.pulse<0){ this.pulseDir*=-1; this.pulse=constrain(this.pulse,0,1); }
        }
      }
      display(){
        push(); translate(this.pos.x,this.pos.y); if(this.isHovered && !this.isDragging) scale(1.05);
        stroke(this.isHovered? 'rgb(0,255,0)':'#fff'); strokeWeight(this.isHovered?3:1);
        if(this.isLinked){
          let e = .5*(1 - cos(this.pulse*PI)), a = 50 + e*100; noStroke(); fill(255,a); rect(0,0,this.width+5,this.height+5,8);
          stroke(this.isHovered? 'rgb(0,255,0)':'#fff'); strokeWeight(this.isHovered?3:1);
          fill('#fff'); rect(0,0,this.width,this.height,5); noStroke(); fill('#000'); text(this.text,0,0);
        }else{
          fill('#000'); rect(0,0,this.width,this.height,5); noStroke(); fill('#fff'); text(this.text,0,0);
        }
        pop();
      }
    }
    class Particle{
      constructor(x,y){ this.pos=createVector(x,y); this.vel=p5.Vector.random2D().mult(random(2,6)); this.lifespan=random(150,255); this.decay=random(3,6); }
      update(){ this.pos.add(this.vel); this.vel.mult(.98); this.lifespan -= this.decay; }
      isDead(){ return this.lifespan<0; }
      display(){ let f=random(100,255); noStroke(); fill(f,this.lifespan); rect(this.pos.x,this.pos.y,4,4); }
    }
  </script>
</body>
</html>
