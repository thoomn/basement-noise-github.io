<script>
/* ======== p5 + Wheel State ======== */
let pg;                     // offscreen buffer for crisp wheel rendering
let wheelSize, cx, cy;      // responsive sizing
let angle = 0;              // current rotation
let spinVel = 0;            // angular velocity
let spinning = false;
let slices = [];            // {name, file, sound:p5.SoundFile|null}
let sliceAngle = 0;

let audioReady = false;
let confetti = [];
let winIndex = -1;
let lastPlayed = null;

/* DOM refs */
const fileInput = document.getElementById('file-input') || null; // if you used a hidden input
const wrap = document.getElementById('roulette-wrap');

/* ========== Audio unlock ========== */
function ensureAudio() {
  if (audioReady) return true;
  if (typeof userStartAudio === 'function') {
    userStartAudio();
    audioReady = true;
    return true;
  }
  return false;
}

/* ========== Upload handling ========== */
function addSamplesFromFiles(files) {
  for (const f of files) {
    const url = URL.createObjectURL(f);
    loadSound(url, snd => {
      slices.push({ name: f.name, file: url, sound: snd });
      rebuildWheel();
    }, e => console.warn('loadSound error', e));
  }
}

if (fileInput) {
  fileInput.addEventListener('change', e => {
    if (!e.target.files.length) return;
    ensureAudio();
    addSamplesFromFiles(e.target.files);
    e.target.value = '';
  });
}

/* ========== p5 core ========== */
function setup() {
  // canvas sized to wrapper width (square)
  const sz = Math.min(820, document.getElementById('roulette-wrap').clientWidth);
  const c = createCanvas(sz, sz);
  c.parent('roulette-wrap');
  wheelSize = min(width, height);
  cx = width / 2; cy = height / 2;

  pixelDensity(1);
  textFont('Courier New');
  angleMode(RADIANS);

  // offscreen buffer for the wheel face
  pg = createGraphics(wheelSize, wheelSize);
  pg.angleMode(RADIANS);
  pg.textAlign(CENTER, CENTER);
  pg.textFont('Courier New');

  // click anywhere to unlock audio
  canvas.mousePressed(() => ensureAudio());
}

function windowResized() {
  const sz = Math.min(820, document.getElementById('roulette-wrap').clientWidth);
  resizeCanvas(sz, sz);
  wheelSize = min(width, height);
  cx = width / 2; cy = height / 2;
  pg = createGraphics(wheelSize, wheelSize);
  pg.angleMode(RADIANS);
  pg.textAlign(CENTER, CENTER);
  pg.textFont('Courier New');
  redrawWheel();
}

function draw() {
  clear(); // transparent, so site background shows through

  // spin physics
  if (spinning) {
    angle += spinVel;
    spinVel *= 0.985;                  // damping
    if (abs(spinVel) < 0.0025) {       // snap to nearest slice
      spinVel = 0;
      spinning = false;
      snapToSlice();
      celebrate(winIndex);
      playWinner(winIndex);
    }
  }

  // draw wheel
  push();
  translate(cx, cy);
  rotate(angle);
  imageMode(CENTER);
  image(pg, 0, 0);
  pop();

  // draw confetti
  for (let i = confetti.length - 1; i >= 0; i--) {
    const p = confetti[i];
    p.vy += 0.15;
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 1;
    noStroke();
    fill(255, p.life * 2);
    rect(p.x, p.y, 4, 4);
    if (p.life <= 0) confetti.splice(i, 1);
  }
}

/* ========== Wheel building ========== */
function rebuildWheel() {
  sliceAngle = TWO_PI / max(1, slices.length || 1);
  redrawWheel();
}

function redrawWheel() {
  pg.clear();
  const r = wheelSize * 0.42;
  const rLabel = r * 0.70;

  // outer ring
  pg.noFill();
  pg.stroke(255);
  pg.strokeWeight(2);
  pg.circle(wheelSize / 2, wheelSize / 2, r * 2);

  if (!slices.length) return;

  for (let i = 0; i < slices.length; i++) {
    const a0 = i * sliceAngle - HALF_PI;       // start from up (−90°) so pointer on right feels natural
    const a1 = a0 + sliceAngle;

    // slice fill
    pg.noStroke();
    pg.fill(i % 2 ? 30 : 40);
    pg.arc(wheelSize / 2, wheelSize / 2, r * 2, r * 2, a0, a1, PIE);

    // slice divider
    pg.stroke(90);
    pg.strokeWeight(1);
    pg.line(
      wheelSize / 2 + cos(a0) * r,
      wheelSize / 2 + sin(a0) * r,
      wheelSize / 2,
      wheelSize / 2
    );

    // label
    pg.push();
    pg.translate(wheelSize / 2, wheelSize / 2);
    const mid = a0 + sliceAngle / 2;
    pg.rotate(mid);
    pg.noStroke();
    pg.fill(200);
    pg.textSize(12);
    const label = truncLabel(slices[i].name);
    pg.text(label, 0, -rLabel);
    pg.pop();
  }

  // hub
  pg.noStroke();
  pg.fill(0);
  pg.circle(wheelSize / 2, wheelSize / 2, 40);
  pg.stroke(255);
  pg.noFill();
  pg.circle(wheelSize / 2, wheelSize / 2, 40);
}

function truncLabel(s) {
  const max = 26;
  if (s.length <= max) return s;
  const dot = s.lastIndexOf('.');
  const base = dot > 0 ? s.slice(0, dot) : s;
  return base.length > max ? base.slice(0, max - 1) + '…' : base;
}

/* ========== Spin control ========== */
function spin() {
  if (!slices.length || spinning) return;
  ensureAudio();

  // random initial velocity (positive = CW)
  spinVel = random(0.25, 0.35);
  spinning = true;

  // stop anything currently playing
  if (lastPlayed && lastPlayed.isPlaying()) lastPlayed.stop();
}

function snapToSlice() {
  // normalize current facing angle to [0..TWO_PI)
  // Pointer is on the RIGHT, so “winning” slice is at angle 0 (pointing +X)
  const facing = ((-angle) % TWO_PI + TWO_PI) % TWO_PI; // convert rotation to wheel space
  const idx = floor(((facing + HALF_PI) % TWO_PI) / sliceAngle); // compensate our slice start at -HALF_PI
  winIndex = constrain(idx, 0, slices.length - 1);

  // rotate to center the slice exactly at pointer (right side = 0 rad)
  const sliceMid = winIndex * sliceAngle + sliceAngle / 2 - HALF_PI;
  angle = -sliceMid; // so that sliceMid ends at +X after rotation

  // brief highlight of winner slice by redrawing with bright edge
  drawWinnerEdge(winIndex);
}

function drawWinnerEdge(i) {
  const r = wheelSize * 0.42;
  const a0 = i * sliceAngle - HALF_PI;
  const a1 = a0 + sliceAngle;

  pg.push();
  pg.noFill();
  pg.stroke(255);
  pg.strokeWeight(3);
  pg.arc(wheelSize / 2, wheelSize / 2, r * 2 + 4, r * 2 + 4, a0, a1);
  pg.pop();
}

/* ========== Celebration + audio ========== */
function celebrate(i) {
  // pulse ring overlay
  const ring = document.createElement('div');
  ring.className = 'win-ring';
  wrap.appendChild(ring);
  setTimeout(() => wrap.removeChild(ring), 820);

  // confetti burst
  const n = 70;
  for (let k = 0; k < n; k++) {
    confetti.push({
      x: cx + (k % 2 ? 12 : -12),
      y: cy,
      vx: random(-3, 3),
      vy: random(-6, -2),
      life: random(40, 70)
    });
  }
}

function playWinner(i) {
  if (i < 0 || i >= slices.length) return;
  const snd = slices[i].sound;
  if (!snd) return;
  if (lastPlayed && lastPlayed.isPlaying()) lastPlayed.stop();
  snd.stop();  // ensure we start from 0
  snd.setVolume(0.9);
  snd.play();
  lastPlayed = snd;
}

/* ========== Controls (wire these to your buttons) ========== */
window.SR_upload = () => {
  ensureAudio();
  const el = document.createElement('input');
  el.type = 'file'; el.accept = 'audio/*'; el.multiple = true;
  el.onchange = e => addSamplesFromFiles(e.target.files);
  el.click();
};

window.SR_spin = spin;

window.SR_clear = () => {
  if (lastPlayed && lastPlayed.isPlaying()) lastPlayed.stop();
  slices.forEach(s => s.sound && s.sound.stop());
  slices = [];
  winIndex = -1;
  angle = 0; spinVel = 0; spinning = false;
  rebuildWheel();
};

/* Optional: spin by dragging when idle */
let prevX = null;
function mousePressed() {
  prevX = mouseX;
}
function mouseDragged() {
  if (spinning || !prevX) return;
  const dx = mouseX - prevX;
  angle += dx * 0.005;
  prevX = mouseX;
}
function mouseReleased() {
  prevX = null;
}
</script>
